//! # Board Module
//!
//! The `board` module is responsible for defining and rendering the Sudoku
//! board.
//! It includes the logic for laying out the cells in a grid,
//! handling user interactions,
//! and updating the state of the board as the game progresses.
//!
//! This module provides the [`SudokuBoard`] component,
//! which is the central element of the Sudoku game interface,
//! displaying the puzzle to the user and allowing interaction
//!  with individual cells.

use dioxus::prelude::*;

use crate::components::cell::Cell;
use crate::utils::{create_sudoku, get_class, get_conflicting_cells};

/// Shared State for clicked [`Cell`]
///
/// Represents globally across the app which cell is clicked by id.
pub struct Clicked(pub u8);

/// Shared State for clicked [`Cell`]'s related [`Cell`]s
///
/// Represents globally across the app which cells, by id,
/// are related to the clicked [`Cell`].
///
/// [`Cell`]s are related if they share the same row, column, or sub-grid in
/// a Sudoku board.
///
/// See also: [`get_related_cells`](crate::utils::get_related_cells).
pub struct Related(pub Vec<u8>);

/// Shared State for clicked [`Cell`]'s conficts
///
/// Represents globally across the app which cells, by id,
/// are in conflict to the clicked [`Cell`].
///
/// [`Cell`]s are in conflict if they share the same row, column, or sub-grid in
/// a Sudoku board and have the same value.
///
/// See also: [`get_related_cells`](crate::utils::get_related_cells)
/// and [`get_conflicting_cells`].
pub struct Conflicting(pub Vec<u8>);

/// Shared State for the initial [`SudokuBoard`] puzzle
pub struct SudokuPuzzle(pub [u8; 81]);
impl SudokuPuzzle {
    #[must_use]
    pub fn new() -> Self {
        Self(create_sudoku())
    }
}
impl Default for SudokuPuzzle {
    fn default() -> Self {
        Self::new()
    }
}

#[derive(Props, PartialEq, Eq)]
struct NumberButtonProps {
    number: u8,
}

fn NumberButton(cx: Scope<NumberButtonProps>) -> Element {
    let number = cx.props.number;
    let class: &str = match number {
        0 => "input icon delete",
        _ => "input number",
    };

    // Unpack shared states
    let sudoku =
        use_shared_state::<SudokuPuzzle>(cx).expect("failed to get sudoku puzzle shared state");
    let conflicting =
        use_shared_state::<Conflicting>(cx).expect("failed to get conflicting cells shared state");
    let clicked = use_shared_state::<Clicked>(cx)
        .expect("failed to get clicked cell shared state")
        .read()
        .0;

    cx.render(rsx!(
        button {
            class: "{class}",
            onclick: move |_| {
                // chaging the clicked cell value to the button number
                sudoku.write().0[clicked as usize] = number;
                conflicting.write().0 = get_conflicting_cells(&sudoku.read().0, clicked);
            },
            "{number}"
        }
    ))
}

/// Component to render a Sudoku board.
///
/// This component renders a Sudoku board which can be either randomly generated.
///
/// Each cell in the board is represented as a [`Cell`].
/// Cells that were generated by the initial puzzle are not mutable,
/// i.e cannot have the values changed by the user.
///
/// ## Panics
///
/// The component will panic if cannot convert any of the Sudoku's board cells
/// indexes from `usize` into a `u8`
///
#[allow(clippy::module_name_repetitions)]
#[must_use]
pub fn SudokuBoard(cx: Scope) -> Element {
    // Unpack shared states
    let sudoku = use_shared_state::<SudokuPuzzle>(cx)
        .expect("failed to get sudoku puzzle shared state")
        .read()
        .0;

    // Initialize all shared states
    use_shared_state_provider(cx, || Clicked(90)); // this will never imply in a highlighted cell at initial state
    use_shared_state_provider(cx, || Related(vec![]));
    use_shared_state_provider(cx, || Conflicting(vec![]));

    // We need to track clicked to send to the `select` Cell prop
    let clicked = use_shared_state::<Clicked>(cx);

    cx.render(rsx!(div {
        id: "container",

        // Render Cells
        for (index, &value) in sudoku.iter().enumerate() {
                rsx!(Cell {
                    index: u8::try_from(index).expect("cannot convert from u8"),
                    value: value,
                    selected: clicked.expect("failed to get clicked shared state").read().0 == u8::try_from(index).expect("cannot convert from u8"),
                    highlighted: false,
                    class: get_class(u8::try_from(index).expect("cannot convert from u8")),
                    mutable: sudoku[index] == 0,
                })
            }

        // Render NumberButtons
        for i in 1..=9 {
            NumberButton {
                number: i
            }
        }

        // Render "DeleteButton", a.k.a number is 0
        NumberButton {
            number: 0,
        }
    }))
}
